The assignment requires a combination of:
OOP (classes + inheritance)
Threads (parallel baristas)
Synchronization (avoid race conditions)
Order tracking (state machine)




Required Classes and Responsibilities
1. Menu
List of items (coffee, tea, etc.)
Each item has:
price
prep time
Functionality: display items, allow selection
2. Order
Attributes:
customer ID
selected items
total price
current status: WAITING → IN PROGRESS → COMPLETED
estimated time
Methods:
calculate price
update status
3. Barista
Runs in a thread
Each barista handles one order at a time
Methods:
take order
prepare order
notify customer
4. Customer
Places order
Receives notification
Displays total price
CODE:



##Order Class
import time
import threading
from enum import Enum


class Status(Enum):
   WAITING = "waiting"
   IN_PROGRESS = "in progress"
   COMPLETED = "completed"


class Order:
   def __init__(self, customer, items):
       self.customer = customer
       self.items = items
       self.status = Status.WAITING
       self.total_price = sum(item.price for item in items)
       self.total_time = sum(item.prep_time for item in items)


   def update_status(self, new_status):
       self.status = new_status






##Menu and MenuItem Classes
class MenuItem:
   def __init__(self, name, price, prep_time):
       self.name = name
       self.price = price
       self.prep_time = prep_time


class Menu:
   def __init__(self):
       self.items = [
           MenuItem("Coffee", 3.0, 5),
           MenuItem("Tea", 2.5, 4),
           MenuItem("Croissant", 4.0, 3),
           MenuItem("Sandwich", 6.0, 7)
       ]


   def show(self):
       for i, item in enumerate(self.items):
           print(f"{i+1}. {item.name} - €{item.price}")


   def choose(self, indices):
       return [self.items[i-1] for i in indices]




##Barista Thread Class
class Barista(threading.Thread):
   def __init__(self, name, order_queue):
       super().__init__()
       self.name = name
       self.order_queue = order_queue


   def run(self):
       while True:
           order = self.order_queue.get()
           if order is None:
               break


           order.update_status(Status.IN_PROGRESS)
           print(f"{self.name} is preparing order for {order.customer}...")


           time.sleep(order.total_time)


           order.update_status(Status.COMPLETED)
           print(f"{self.name} completed the order for {order.customer}!")
           order.customer.notify(order)


           self.order_queue.task_done()






##Customer Class
class Customer:
   def __init__(self, name):
       self.name = name


   def notify(self, order):
       print(f"Customer {self.name}, your order is ready!")
       print(f"Total price: €{order.total_price}")






##Running the Simulation
from queue import Queue


order_queue = Queue()


# Start baristas
baristas = [Barista(f"Barista {i}", order_queue) for i in range(2)]
for b in baristas:
   b.start()


# Create menu and customers
menu = Menu()
c1 = Customer("Alice")
c2 = Customer("Bob")


# Alice orders coffee + croissant
items1 = menu.choose([1, 3])
order_queue.put(Order(c1, items1))


# Bob orders tea
items2 = menu.choose([2])
order_queue.put(Order(c2, items2))


order_queue.join()


# Stop baristas
for _ in baristas:
   order_queue.put(None)


WHat it prints:

Barista 0 is preparing order for <__main__.Customer object at 0x102e762d0>...Barista 1 is preparing order for <__main__.Customer object at 0x102e76300>...

Barista 1 completed the order for <__main__.Customer object at 0x102e76300>!
Customer Bob, your order is ready!
Total price: €2.5
Barista 0 completed the order for <__main__.Customer object at 0x102e762d0>!
Customer Alice, your order is ready!
Total price: €7.0

Process finished with exit code 0
